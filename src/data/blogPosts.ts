export type BlogPost = {
  slug: string;
  title: string;
  excerpt: string;
  date: string; // e.g. "2025-01-30" or "Jan 30, 2025"
  authorName: string;
  authorTitle: string;
  content: string; // HTML string or plain text for the full post body
};

export const blogPosts: BlogPost[] = [
  {
    slug: 'introduction-to-homomorphic-encryption',
    title: 'Introduction to Homomorphic Encryption',
    excerpt: 'A primer on how homomorphic encryption enables computation on encrypted data without ever decrypting it.',
    date: 'Jan 30, 2025',
    authorName: 'Dhruv Chopra',
    authorTitle: 'Founder & CEO',
    content: `
    Data is the new oil. In today's world, data is the currency upon which multi-billion dollar industries are built and operate on. Thousands of terabytes of data are generated every second, even from seemingly routine activities such as, checking into your hotel, posting and interacting with friends on social media and even just casually scrolling your news feed. This data is processed and analysed to draw various useful insights. These insights are leveraged for a variety of applications such as better product recommendations while you shop online, enabling you to skip the queue at the airport using faster biometric based identity verification, better advertisements finetuned and suited as per your likings, shop products from anywhere in the world sitting on your couch, have personalized chats with your favourite LLM and so on.<br><br>
However, this very data generated by you, has patterns and components very unique to you. Your sensitive biometric features, your financial details, your personal photographs, your likes-dislikes interests-disinterests, your online interaction patterns and behaviour, and so on can all form your digital identity.<br><br>
As data processing and insights get increasingly sophisticated and widely adopted, with data being shared across multiple entities to extract meaning, your digital footprint is ever increasing. This leaves your digital identity vulnerable to misuse and thefts, the effects of which can be quite grave.<br><br>
Over the years, a variety of encryption techniques have been devised to help mitigate the threats to data theft and misuse. However, most of these techniques are partial, meaning data stays encrypted only during certain phases of its life cycle, such as when data is sent across parties(in transit) or stored(at rest). They do not allow for data to be encrypted when drawing insights from it or processing it (data in-use encryption). Thus, data is never truly encrypted at all times during its entire lifecycle, leaving it vulnerable.<br><br>
Homomorphic Encryption, on the other hand is an encryption technique which allows for data to stay encrypted end to end, during its entire lifecycle: in transit, at rest and in use. This enables you to realize all the benefits of sharing data with companies and other entities, without having to worry about data privacy, misuse and theft. Companies can draw insights, extract patterns, perform analytics and apply intelligence on top of your data, all while it stays completely encrypted! Only you, as the owner of your generated data, possess the private key to decipher your raw data and the results of all the processing performed by any third party. All processing happens in the encrypted domain, without the need to ever decrypt your sensitive data.<br><br>
This establishes a zero trust environment. This enables various operations on sensitive data such as biometric matching for access control, processing financial transactions' data and deriving insights data such as past medical records or user history, to be done in a completely private manner.<br><br>
Facilitating these operations on data in the encrypted domain, however, comes at a cost: latency. Recent advancements have brought latency of encrypted computations closer to their plaintext counterparts (better algorithms, compiler optimizations, specialized hardware accelerators).<br><br>
Let's go through a small example to better appreciate the truly end to end encryption that HE enables (ref. HE end to end for illustration). Say that you as a client want to add two numbers(3 and 7 in the illustration), and you want to leverage the power of the cloud to do so. However, you do not want the cloud to know what numbers you are adding. You want to keep that information private. So, you as the client, generate a set of public and private keys, and encrypt the numbers using your private key. You then send the encrypted numbers across to the cloud. You also send a set of public keys, which enable the cloud to perform different types of computations upon your encrypted data. The cloud operates upon the encrypted data and computes a result, which is still in the encrypted domain. This encrypted result is sent back to you, the client. Then, using your private key again, you decrypt the result and extract out the information (the sum of the numbers 3 and 7 = 10 in the illustration).<br><br>
Thus, as we saw in the example, data stays encrypted during its entire lifecycle, right from leaving the client device, while processing in the backend servers and clouds, up to the result entering back into the client device. Traditional encryption schemes would have had required the cloud to decrypt the numbers that you sent, before adding them up and sending you back the result. HE on the other hand, allows the cloud to compute upon the encrypted ciphertexts.<br><br>
This unlocks a plethora of applications and a variety of use cases, enabling cross entity collaboration to draw insights, all while maintaining complete client data privacy, ensuring data safety, complying with regulations and adhering to disclosure policies and data agreements.
In the next blog, we will dive deeper into the technical details of how Homomorphic Encryption schemes achieve the promise of true end to end encryption and data privacy.
    `.trim(),
  },
  // Add more posts by copying the object above and changing slug, title, excerpt, date, authorName, authorTitle, and content.
];

export function getPostBySlug(slug: string): BlogPost | undefined {
  return blogPosts.find((post) => post.slug === slug);
}

export function getAllSlugs(): string[] {
  return blogPosts.map((post) => post.slug);
}
